# 推薦バッチ処理 仕様書

## 概要

人材と案件のマッチングスコアを計算し、閾値以上のスコアを持つ組み合わせを推薦DBに登録するバッチ処理システム。

## アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    推薦レコード生成フロー                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐  │
│  │   案件DB     │    │   人材DB     │    │   推薦DB     │  │
│  │  (Kintone)   │    │  (Kintone)   │    │  (Kintone)   │  │
│  └──────┬───────┘    └──────┬───────┘    └──────┬───────┘  │
│         │                   │                   │          │
│         ▼                   ▼                   ▼          │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              マッチングスコア計算エンジン              │  │
│  │  - 職種マッチング                                     │  │
│  │  - スキルキーワード出現回数カウント                    │  │
│  │  - 経歴書内キーワード検索                             │  │
│  └──────────────────────────────────────────────────────┘  │
│                          │                                 │
│                          ▼                                 │
│  ┌──────────────────────────────────────────────────────┐  │
│  │                   閾値フィルタリング                   │  │
│  │  スコア >= 閾値 のペアのみ推薦DBに登録                 │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## マッチングスコア計算ロジック

### 計算方法

1. 案件の「職種_ポジション」と「スキル」からキーワードを抽出
2. 人材の以下フィールドでキーワード出現回数をカウント:
   - 職種（複数選択）
   - 言語_ツール（テキスト）
   - 主な実績_PR_職務経歴（テキスト）
3. 全キーワードの出現回数を合計 = マッチングスコア

### 実装ファイル

- `lib/matching/calculateScore.ts`

```typescript
// スコア計算の例
const result = calculateMatchScore(talent, job);
// result.score: 合計スコア
// result.matchDetails: 各キーワードのマッチ詳細
```

## バッチ処理の種類

### 1. 定期バッチ処理（推奨）

**スクリプト**: `scripts/refresh-recommendations.ts`

**実行方法**:
```bash
# 通常実行
npm run recommend:batch

# ドライラン（変更を確認のみ）
npm run recommend:batch:dry

# フル計算（全組み合わせを再計算）
npm run recommend:batch -- --full

# 閾値を指定
npm run recommend:batch -- --threshold 5
```

**処理フロー**:

```
1. DB設定を取得（閾値、前回バッチ日時、前回閾値）
         │
         ▼
2. 閾値変更を検知
   ├── 上昇: 削除のみモード（閾値未満レコードを削除）
   ├── 下降: フル計算モード（新たに閾値を満たすペアを探索）
   └── 変更なし: インクリメンタル計算
         │
         ▼
3. アクティブな案件を取得（掲載用ステータス=有、募集中）
         │
         ▼
4. 全人材を取得（退会者除外）
         │
         ▼
5. スコア計算
   ├── インクリメンタル: 更新された案件/人材の組み合わせのみ
   └── フル: 全組み合わせ
         │
         ▼
6. 差分計算
   ├── 削除: 案件非アクティブ / 人材退会 / スコア閾値未満
   ├── 更新: スコアが変更されたレコード
   ├── 作成: 新規の閾値以上ペア
   └── 保持: 変更なし（AIマッチ済み/おすすめは常に保持）
         │
         ▼
7. Kintone推薦DBに反映
         │
         ▼
8. バッチ状態を更新（lastBatchTime, lastThreshold）
```

### 2. リアルタイム処理（Webhook）

**エンドポイント**: `/api/webhooks/job-created`

案件が追加された際にKintoneからWebhookで呼び出され、即座に推薦レコードを作成。

**処理内容**:
- 追加された案件に対して全人材のスコアを計算
- 閾値以上のスコアを持つ人材の推薦レコードを作成/更新

**テスト方法**:
```bash
npm run test:webhook
```

## 閾値設定

### 設定方法

1. **管理画面から設定**
   - 管理ダッシュボード → バッチ設定 → スコア閾値

2. **API経由で設定**
   ```bash
   # 取得
   curl http://localhost:3000/api/admin/batch-settings

   # 更新
   curl -X POST http://localhost:3000/api/admin/batch-settings \
     -H "Content-Type: application/json" \
     -d '{"scoreThreshold": 5}'
   ```

### 閾値変更時の動作

| 変更 | 動作 | 理由 |
|------|------|------|
| 上昇 (3→5) | 削除のみ | スコア3-4のレコードを削除 |
| 下降 (5→3) | フル計算 | 新たにスコア3-4のペアを探す必要 |
| 変更なし | インクリメンタル | 更新分のみ計算 |

## 保護レコード

以下の条件のレコードは削除されない（スコアが閾値未満でも保持）:

1. **AIマッチ実行済み**: `AIマッチ実行状況 = "実行済み"`
2. **担当者おすすめ**: `担当者おすすめ = "おすすめ"`

ただし、以下の場合は保護レコードも削除:
- 案件が非アクティブになった場合
- 人材が退会した場合

## DBスキーマ

### app_settings テーブル

```sql
CREATE TABLE app_settings (
  id TEXT PRIMARY KEY DEFAULT 'default',
  score_threshold INTEGER NOT NULL DEFAULT 3,  -- スコア閾値
  max_per_job INTEGER NOT NULL DEFAULT 50,     -- 案件あたり最大推薦数
  last_batch_time TIMESTAMP,                   -- 前回バッチ実行日時
  last_threshold INTEGER,                       -- 前回バッチ時の閾値
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

### Kintone 推薦DB フィールド

| フィールド | 説明 |
|-----------|------|
| 人材ID | 人材のauth_user_id |
| 案件ID | 案件レコードID |
| 適合スコア | マッチングスコア |
| AIマッチ実行状況 | 未実行/実行済み |
| 担当者おすすめ | おすすめフラグ |

## インクリメンタル計算

### 概要

全組み合わせを毎回計算するのではなく、前回バッチ以降に更新された案件・人材の組み合わせのみを再計算することで高速化。

### 判定条件

```
計算対象 = 案件が更新された OR 人材が更新された
         = job.updatedAt > lastBatchTime OR talent.updatedAt > lastBatchTime
```

### 効果

| 規模 | フル計算 | インクリメンタル |
|------|----------|------------------|
| 100案件 × 100人材 | 10,000回 | 更新分のみ |
| 1000案件 × 1000人材 | 1,000,000回 | 更新分のみ |

## エラーハンドリング

### バッチ処理の失敗

- エラー発生時はプロセスが終了（exit code 1）
- 途中で失敗した場合、次回実行で差分更新により整合性を回復

### Kintone API制限

- バッチサイズ: 100件ずつ処理
- 並列度: 逐次処理（APIレート制限考慮）

## npmスクリプト一覧

| スクリプト | 説明 |
|-----------|------|
| `npm run recommend:batch` | 推薦レコード更新バッチ |
| `npm run recommend:batch:dry` | ドライラン |
| `npm run recommend:reset` | 推薦レコード全削除 |
| `npm run test:webhook` | Webhookテスト |

## AWS Lambda + Step Functions（実装済み）

### アーキテクチャ

```
EventBridge (毎日JST 02:00 / UTC 17:00)
    ↓
Step Functions
    ├── GetJobsFunction     (案件・人材一覧取得、最大2分)
    ├── ProcessJobFunction  (案件ごとに並列処理、最大5並列)
    └── UpdateStateFunction (バッチ状態更新)
```

### Lambda 関数

| 関数名 | 説明 | タイムアウト |
|--------|------|-------------|
| `proworks-recommend-get-jobs-{env}` | 案件・人材一覧取得、DB設定取得 | 120秒 |
| `proworks-recommend-process-job-{env}` | 1案件の推薦レコード処理 | 300秒 |
| `proworks-recommend-update-state-{env}` | バッチ状態（lastBatchTime等）更新 | 60秒 |

### デプロイ環境

| 環境 | スタック名 | Step Functions |
|------|-----------|----------------|
| dev | `proworks-recommend-batch-dev` | `proworks-recommend-batch-dev` |
| prod | `proworks-recommend-batch-prod` | `proworks-recommend-batch-prod` |

### ディレクトリ構成

```
lambda/
├── functions/
│   ├── get-jobs/          # Step 1: 案件・人材取得
│   ├── process-job/       # Step 2: 1案件の推薦処理
│   └── update-state/      # Step 3: 状態更新
├── shared/                # 共有コード
│   ├── kintone.ts         # Kintoneクライアント
│   ├── matching.ts        # マッチングロジック
│   └── db.ts              # DB操作
├── scripts/
│   └── deploy.sh          # デプロイスクリプト
├── template.yaml          # SAMテンプレート
├── statemachine.asl.json  # Step Functions定義
└── samconfig.toml         # デプロイ設定
```

### 手動デプロイ

```bash
cd lambda

# 開発環境にデプロイ
npm run deploy:dev

# 本番環境にデプロイ
npm run deploy:prod
```

### CI/CD 自動デプロイ

GitHub Actions により、`lambda/` ディレクトリに変更があった場合に自動デプロイされます。

| ブランチ | デプロイ先 | ワークフロー |
|---------|-----------|-------------|
| `develop` | dev環境 | `.github/workflows/deploy-lambda.yml` |
| `main` | prod環境 | `.github/workflows/deploy-lambda.yml` |

**処理フロー:**
1. `lambda/**` の変更を検知
2. AWS Secrets Manager から環境変数を取得
3. TypeScript コンパイル & SAM ビルド
4. SAM deploy で Lambda/Step Functions をデプロイ

### 環境変数管理

Lambda 用の環境変数は AWS Secrets Manager で管理:

| シークレット名 | 環境 | 内容 |
|---------------|------|------|
| `proworks/lambda-dev` | dev | Kintone設定（URL, APIトークン, アプリID） |
| `proworks/lambda-prod` | prod | Kintone設定（URL, APIトークン, アプリID） |
| `proworks/database` | 共通 | DATABASE_URL |

**シークレット更新コマンド:**
```bash
# ローカルの.env.aws.devからSecrets Managerに反映
npm run lambda:secrets:push:dev

# ローカルの.env.aws.prodからSecrets Managerに反映
npm run lambda:secrets:push:prod
```

### スケジュールトリガー制御

定期実行（毎日 JST 02:00）のオン/オフを制御できます。

```bash
# トリガー状態を確認
npm run lambda:trigger:status

# dev環境のトリガーを有効化/無効化
npm run lambda:trigger:on:dev
npm run lambda:trigger:off:dev

# prod環境のトリガーを有効化/無効化
npm run lambda:trigger:on:prod
npm run lambda:trigger:off:prod
```

### 手動実行

AWS CLI で Step Functions を手動実行:

```bash
# dev環境
aws stepfunctions start-execution \
  --state-machine-arn "arn:aws:states:ap-northeast-1:217797467306:stateMachine:proworks-recommend-batch-dev" \
  --region ap-northeast-1

# prod環境
aws stepfunctions start-execution \
  --state-machine-arn "arn:aws:states:ap-northeast-1:217797467306:stateMachine:proworks-recommend-batch-prod" \
  --region ap-northeast-1
```

### ログ確認

CloudWatch Logs でログを確認:
- `/aws/lambda/proworks-recommend-get-jobs-{env}`
- `/aws/lambda/proworks-recommend-process-job-{env}`
- `/aws/lambda/proworks-recommend-update-state-{env}`

### 料金目安

- Lambda: 月数百円程度
- Step Functions: 月数十円程度
- 合計: 月1,000円以下
